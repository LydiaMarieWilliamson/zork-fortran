C Copyright (c) 1980, InfoCom Computers and Communications, Cambridge MA 02142
C All rights reserved, commercial usage strictly prohibited.
C Written by R. M. Supnik.
C Revisions Copyright (c) 2021, Darth Spectra (Lydia Marie Williamson).
C
C Resident subroutines for dungeon
	LOGICAL FUNCTION GETREC(INCH,LOC,N,BUF)
	IMPLICIT INTEGER(A-Z)
	PARAMETER (TEXLNT=INT(Z'80'))
	PARAMETER (LASTMASK=INT(Z'80'))
	PARAMETER (KEYMASK=INT(Z'FF'))
	INTEGER*4 LOC
	CHARACTER BUF(TEXLNT)
	CHARACTER IX
	INTEGER KEY(2*TEXLNT)
C	Seed: (3789712696) 0xe1e26d38: 1984-12-28 03:30 UTC
C	CALL INIRND(Z'E1E26D38')
C	DO 1 X=1,INT(Z'100')
C	  KEY(X) = RND(INT(Z'100'))
C1:	CONTINUE
	DATA KEY/
     &	  Z'31',Z'5F',Z'58',Z'D7',Z'99',Z'0E',Z'C2',Z'79',
     &	  Z'F5',Z'A1',Z'CF',Z'23',Z'B6',Z'7E',Z'E4',Z'86',
     &	  Z'DB',Z'3E',Z'65',Z'09',Z'A0',Z'C3',Z'DD',Z'D5',
     &	  Z'EE',Z'3C',Z'B5',Z'E6',Z'1C',Z'5C',Z'04',Z'3A',
     &	  Z'62',Z'CF',Z'19',Z'5E',Z'34',Z'61',Z'18',Z'8F',
     &	  Z'A7',Z'08',Z'BC',Z'57',Z'8C',Z'64',Z'D8',Z'12',
     &	  Z'7D',Z'A0',Z'FA',Z'F7',Z'3E',Z'D5',Z'84',Z'91',
     &	  Z'A0',Z'88',Z'BD',Z'48',Z'D4',Z'EF',Z'6B',Z'F8',
     &	  Z'F8',Z'2F',Z'E4',Z'82',Z'2A',Z'08',Z'D3',Z'DD',
     &	  Z'A1',Z'8A',Z'C8',Z'D8',Z'FD',Z'78',Z'76',Z'73',
     &	  Z'F5',Z'98',Z'12',Z'7F',Z'C6',Z'69',Z'36',Z'28',
     &	  Z'C7',Z'B9',Z'0F',Z'E0',Z'BD',Z'26',Z'DB',Z'5E',
     &	  Z'D2',Z'4B',Z'4E',Z'2E',Z'8A',Z'FA',Z'03',Z'82',
     &	  Z'07',Z'6C',Z'25',Z'7D',Z'70',Z'DA',Z'5C',Z'52',
     &	  Z'B0',Z'6D',Z'82',Z'2A',Z'0A',Z'2F',Z'2D',Z'5C',
     &	  Z'5D',Z'D3',Z'C9',Z'4D',Z'E5',Z'9E',Z'EF',Z'4D',
     &	  Z'6B',Z'D6',Z'41',Z'E3',Z'E6',Z'95',Z'E9',Z'E8',
     &	  Z'4D',Z'49',Z'AF',Z'FC',Z'81',Z'25',Z'17',Z'EC',
     &	  Z'77',Z'60',Z'E0',Z'C3',Z'40',Z'B7',Z'E7',Z'B9',
     &	  Z'BA',Z'6C',Z'AD',Z'D1',Z'15',Z'8B',Z'29',Z'A5',
     &	  Z'70',Z'18',Z'F6',Z'29',Z'3C',Z'D3',Z'5C',Z'1C',
     &	  Z'E3',Z'46',Z'53',Z'C6',Z'C8',Z'D3',Z'5B',Z'A1',
     &	  Z'E2',Z'0C',Z'8D',Z'0A',Z'2C',Z'2D',Z'39',Z'CF',
     &	  Z'CD',Z'26',Z'EC',Z'88',Z'0D',Z'AB',Z'B7',Z'CD',
     &	  Z'67',Z'8E',Z'F5',Z'7C',Z'7B',Z'17',Z'12',Z'FF',
     &	  Z'CC',Z'81',Z'63',Z'F7',Z'C9',Z'EC',Z'3D',Z'3A',
     &	  Z'AC',Z'31',Z'44',Z'8B',Z'32',Z'AD',Z'AC',Z'59',
     &	  Z'5D',Z'52',Z'96',Z'A9',Z'6D',Z'80',Z'B5',Z'1F',
     &	  Z'07',Z'5F',Z'00',Z'6A',Z'51',Z'6C',Z'FB',Z'C7',
     &	  Z'DA',Z'C5',Z'88',Z'A9',Z'0B',Z'2D',Z'E2',Z'96',
     &	  Z'BA',Z'6E',Z'EC',Z'EF',Z'41',Z'56',Z'92',Z'C4',
     &	  Z'0D',Z'1A',Z'0D',Z'9C',Z'CA',Z'0B',Z'95',Z'AA'
     &	/
	READ(INCH,POS=LOC,ERR=200)IX
        N=ICHAR(IX)
	GETREC=AND(N,LASTMASK).NE.0
	N=AND(N,NOT(LASTMASK))
	READ(INCH,POS=LOC+1,ERR=300)BUF(1:N)
	DO 100 I=1,N
	  BUF(I)=CHAR(XOR(ICHAR(BUF(I)),KEY(1+AND(INT(LOC),KEYMASK))))
	  LOC=LOC+1
100	CONTINUE
	LOC=LOC+1
	BUF(N+1)=CHAR(0)
	RETURN
200	WRITE(OUTCH,201)LOC
201	FORMAT('Error reading string size at #I0')
	CALL EXIT
300	WRITE(OUTCH,301)LOC
301	FORMAT('Error reading string line at #I0')
	CALL EXIT
	END

C
C CONVERT ALL ARGUMENTS FROM DICTIONARY NUMBERS (IF POSITIVE)
C TO ABSOLUTE RECORD NUMBERS.
	INTEGER*4 FUNCTION DEREF(N)
	IMPLICIT INTEGER(A-Z)
	INTEGER*4 X
C
	include 'mindex.h'
C
	X=N
C						!SET UP WORK VARIABLES.
	IF(X.GT.0) X=RTEXT(X)
C						!IF >0, LOOK UP IN RTEXT.
	X=IABS(X)
C						!TAKE ABS VALUE.
        DEREF=X
	RETURN
	END
C
C Output random message routine
C Called as:
C	CALL RSPEAK(MSGNUM)
	SUBROUTINE RSPEAK(N)
	IMPLICIT INTEGER(A-Z)
C
        Y=0
        Z=0
	CALL RSPEAK2(DEREF(N),Y,Z)
	RETURN
	END
C
C Output random message with substitutable argument
C Called as:
C	CALL RSPSUB(MSGNUM,SUBNUM)
	SUBROUTINE RSPSUB(N,S1)
	IMPLICIT INTEGER(A-Z)
C
        Z=0
	CALL RSPEAK2(DEREF(N),DEREF(S1),Z)
	RETURN
	END
C
C Output random message with up to two substitutable arguments
C Called as:
C	CALL RSPSB2(MSGNUM,SUBNUM1,SUBNUM2)
	SUBROUTINE    RSPSB2(N,S1,S2)
	IMPLICIT      INTEGER(A-Z)
	CALL RSPEAK2(DEREF(N),DEREF(S1),DEREF(S2))
	RETURN
	END

C Display a substitutable message.
	SUBROUTINE    RSPEAK2(X,Y,Z)
	IMPLICIT      INTEGER(A-Z)
	PARAMETER     (TEXLNT=INT(Z'80'))
	INTEGER*4     X,Y,Z
	CHARACTER(2*TEXLNT) B1
	CHARACTER(TEXLNT) B2
	LOGICAL       LAST,JLAST,GETREC
C
	include 'gamestat.h'
C
	include 'mindex.h'
	include 'io.h'
	LAST=.FALSE.
	IF(X.EQ.0) RETURN
C						!ANYTHING TO DO?
	TELFLG=.TRUE.
C						!SAID SOMETHING.
	DO WHILE(.NOT.LAST)
	  LAST=GETREC(STORYCH,X,N1,B1(1:TEXLNT))
200	  IF(Y.NE.0) THEN
C						!ANY SUBSTITUTABLE?
	  I3=INDEX(B1,'#')
C						!YES, LOOK FOR #.
	  IF (I3.GT.0) THEN
C
C           SUBSTITUTION WITH SUBSTITUTABLE AVAILABLE.
C             I3 IS INDEX OF # IN B1.
C             Y IS LOCATION OF RECORD TO SUBSTITUTE.
C
C           PROCEDURE:
C             1) COPY REST OF B1 TO B2
C             2) READ SUBSTITUTABLE OVER B1 AT I3
C             3) RESTORE TAIL OF ORIGINAL B1
C
C           THE IMPLICIT ASSUMPTION HERE IS THAT THE SUBSTITUTABLE STRING
C           IS VERY SHORT (i.e. MUCH LESS THAN ONE RECORD).
C
	    N2=N1-I3
	    B2(1:N2+1)=B1(I3+1:N1+1)
C                                               !COPY REST OF B1 TO B2.
C
C           READ SUBSTITUTE STRING INTO REMAINDER OF B1, AND DECRYPT IT:
C
            JLAST=GETREC(STORYCH,Y,N3,B1(I3:I3+TEXLNT-1))
C
C           FIND END OF SUBSTITUTE STRING IN B1:
C
	    I3=I3+N3
C
C           PUT TAIL END OF B1 (NOW IN B2) BACK INTO B1 AFTER SUBSTITUTE STRING:
C
	    N1=I3+N2-1
            B1(I3:N1+1)=B2(1:N2+1)
C                                               !COPY REST OF B1 BACK FROM B2.
C
	      Y=Z
C						!SET UP FOR NEXT
	      Z=0
C						!SUBSTITUTION AND
	      GO TO 200
C						!RECHECK LINE.
          END IF
	  END IF
          WRITE(OUTCH,650) (B1(J:J),J=1,N1)
650       FORMAT(128A1)
C						!ON TO NEXT RECORD.
	END DO
C						!CONTINUATION?
	RETURN
C						!NO, EXIT.
	END
C
C Apply objects from parse vector
	LOGICAL FUNCTION OBJACT()
	IMPLICIT INTEGER (A-Z)
	LOGICAL OAPPLI
	include 'parser.h'
	include 'objects.h'
C
	OBJACT=.TRUE.
C						!ASSUME WINS.
	IF(PRSI.EQ.0) GO TO 100
C						!IND OBJECT?
	IF(OAPPLI(OACTIO(PRSI),0)) RETURN
C						!YES, LET IT HANDLE.
C
100	IF(PRSO.EQ.0) GO TO 200
C						!DIR OBJECT?
	IF(OAPPLI(OACTIO(PRSO),0)) RETURN
C						!YES, LET IT HANDLE.
C
200	OBJACT=.FALSE.
C						!LOSES.
	RETURN
	END
C
C Report fatal system error
C Called as:
C	CALL BUG(NO,PAR)
	SUBROUTINE BUG(A,B)
	IMPLICIT INTEGER(A-Z)
	include 'debug.h'
C
	PRINT 100,A,B
	IF(DBGFLG.NE.0) RETURN
	CALL EXIT
C
100	FORMAT('PROGRAM ERROR ',I2,', PARAMETER=',I6)
	END
C
C Set new status for object
C Called by:
C	CALL NEWSTA(OBJECT,STRING,NEWROOM,NEWCON,NEWADV)
	SUBROUTINE NEWSTA(O,R,RM,CN,AD)
	IMPLICIT INTEGER(A-Z)
	include 'objects.h'
C
	CALL RSPEAK(R)
	OROOM(O)=RM
	OCAN(O)=CN
	OADV(O)=AD
	RETURN
	END
C
C Test for object in room
	LOGICAL FUNCTION QHERE(OBJ,RM)
	IMPLICIT INTEGER (A-Z)
	include 'objects.h'
C
	QHERE=.TRUE.
	IF(OROOM(OBJ).EQ.RM) RETURN
C						!IN ROOM?
	DO 100 I=1,R2LNT
C						!NO, SCH ROOM2.
	  IF((OROOM2(I).EQ.OBJ).AND.(RROOM2(I).EQ.RM)) RETURN
100	CONTINUE
	QHERE=.FALSE.
C						!NOT PRESENT.
	RETURN
	END
C
C Test for object empty
	LOGICAL FUNCTION QEMPTY(OBJ)
	IMPLICIT INTEGER (A-Z)
	include 'objects.h'
C
	QEMPTY=.FALSE.
C						!ASSUME LOSE.
	DO 100 I=1,OLNT
	  IF(OCAN(I).EQ.OBJ) RETURN
C						!INSIDE TARGET?
100	CONTINUE
	QEMPTY=.TRUE.
	RETURN
	END
C
C You are dead
	SUBROUTINE JIGSUP(DESC)
	IMPLICIT INTEGER (A-Z)
	LOGICAL YESNO,MOVETO,QHERE,F
	INTEGER RLIST(9)
	include 'parser.h'
	include 'gamestat.h'
	include 'state.h'
	include 'io.h'
	include 'debug.h'
	include 'rooms.h'
	include 'rflag.h'
	include 'rindex.h'
	include 'objects.h'
	include 'oflags.h'
	include 'oindex.h'
	include 'advers.h'
	include 'flags.h'
C
C Initialized data
	DATA RLIST/8,6,36,35,34,4,34,6,5/
C JIGSUP, PAGE 2
C
	CALL RSPEAK(DESC)
C						!DESCRIBE SAD STATE.
	PRSCON=1
C						!STOP PARSER.
	IF(DBGFLG.NE.0) RETURN
C						!IF DBG, EXIT.
	AVEHIC(WINNER)=0
C						!GET RID OF VEHICLE.
	IF(WINNER.EQ.PLAYER) GO TO 100
C						!HIMSELF?
	CALL RSPSUB(432,ODESC2(AOBJ(WINNER)))
C						!NO, SAY WHO DIED.
	CALL NEWSTA(AOBJ(WINNER),0,0,0,0)
C						!SEND TO HYPER SPACE.
	RETURN
C
100	IF(ENDGMF) GO TO 900
C						!NO RECOVERY IN END GAME.
	IF(DEATHS.GE.2) GO TO 1000
C						!DEAD TWICE? KICK HIM OFF.
	IF(.NOT.YESNO(10,9,8)) GO TO 1100
C						!CONTINUE?
C
	DO 50 J=1,OLNT
C						!TURN OFF FIGHTING.
	  IF(QHERE(J,HERE))   OFLAG2(J)=IAND(OFLAG2(J),not(FITEBT))
50	CONTINUE
C
	DEATHS=DEATHS+1
	CALL SCRUPD(-10)
C						!CHARGE TEN POINTS.
	F=MOVETO(FORE1,WINNER)
C						!REPOSITION HIM.
	EGYPTF=.TRUE.
C						!RESTORE COFFIN.
	IF(OADV(COFFI).EQ.WINNER) CALL NEWSTA(COFFI,0,EGYPT,0,0)
	OFLAG2(DOOR)=IAND(OFLAG2(DOOR),not(TCHBT))
	OFLAG1(ROBOT)=IAND(IOR(OFLAG1(ROBOT),VISIBT),not(NDSCBT))
	IF((OROOM(LAMP).NE.0).OR.(OADV(LAMP).EQ.WINNER))
     &	CALL NEWSTA(LAMP,0,LROOM,0,0)
C
C NOW REDISTRIBUTE HIS VALUABLES AND OTHER BELONGINGS.
C
C THE LAMP HAS BEEN PLACED IN THE LIVING ROOM.
C THE FIRST 8 NON-VALUABLES ARE PLACED IN LOCATIONS AROUND THE HOUSE.
C HIS VALUABLES ARE PLACED AT THE END OF THE MAZE.
C REMAINING NON-VALUABLES ARE PLACED AT THE END OF THE MAZE.
C
	I=1
	DO 200 J=1,OLNT
C						!LOOP THRU OBJECTS.
	  IF((OADV(J).NE.WINNER).OR.(OTVAL(J).NE.0))
     &	GO TO 200
	  I=I+1
	  IF(I.GT.9) GO TO 400
C						!MOVE TO RANDOM LOCATIONS.
	  CALL NEWSTA(J,0,RLIST(I),0,0)
200	CONTINUE
C
400	I=RLNT+1
C						!NOW MOVE VALUABLES.
	NONOFL=RAIR+RWATER+RSACRD+REND
C						!DONT MOVE HERE.
	DO 300 J=1,OLNT
	  IF((OADV(J).NE.WINNER).OR.(OTVAL(J).EQ.0))
     &	GO TO 300
250	  I=I-1
C						!FIND NEXT ROOM.
	  IF(IAND(RFLAG(I),NONOFL).NE.0) GO TO 250
	  CALL NEWSTA(J,0,I,0,0)
C						!YES, MOVE.
300	CONTINUE
C
	DO 500 J=1,OLNT
C						!NOW GET RID OF REMAINDER.
	  IF(OADV(J).NE.WINNER) GO TO 500
450	  I=I-1
C						!FIND NEXT ROOM.
	  IF(IAND(RFLAG(I),NONOFL).NE.0) GO TO 450
	  CALL NEWSTA(J,0,I,0,0)
500	CONTINUE
	RETURN
C
C CAN'T OR WON'T CONTINUE, CLEAN UP AND EXIT.
C
900	CALL RSPEAK(625)
C						!IN ENDGAME, LOSE.
	GO TO 1100
C
1000	CALL RSPEAK(7)
C						!INVOLUNTARY EXIT.
1100	CALL SCORE(.FALSE.)
C						!TELL SCORE.
	CLOSE(STORYCH)
	CALL EXIT
	END
C
C Get actor associated with object
	INTEGER FUNCTION OACTOR(OBJ)
	IMPLICIT INTEGER(A-Z)
	include 'advers.h'
C
	DO 100 I=1,ALNT
C						!LOOP THRU ACTORS.
	  OACTOR=I
C						!ASSUME FOUND.
	  IF(AOBJ(I).EQ.OBJ) RETURN
C						!FOUND IT?
100	CONTINUE
	CALL BUG(40,OBJ)
C						!NO, DIE.
	RETURN
	END
C
C Compute probability
	LOGICAL FUNCTION PROB(G,B)
	IMPLICIT INTEGER(A-Z)
	include 'flags.h'
C
	I=G
C						!ASSUME GOOD LUCK.
	IF(BADLKF) I=B
C						!IF BAD, TOO BAD.
	PROB=RND(100).LT.I
C						!COMPUTE.
	RETURN
	END
C
C Print room description
C RMDESC prints a description of the current room.
C It is also the processor for verbs 'LOOK' and 'EXAMINE'.
	LOGICAL FUNCTION RMDESC(FULL)
C
C FULL=	0/1/2/3=	SHORT/OBJ/ROOM/FULL
C
	IMPLICIT INTEGER (A-Z)
	LOGICAL PROB,LIT,RAPPLI
	include 'parser.h'
	include 'gamestat.h'
	include 'screen.h'
	include 'rooms.h'
	include 'rflag.h'
	include 'xsrch.h'
	include 'objects.h'
	include 'advers.h'
	include 'verbs.h'
	include 'flags.h'
C RMDESC, PAGE 2
C
	RMDESC=.TRUE.
C						!ASSUME WINS.
	IF(PRSO.LT.XMIN) GO TO 50
C						!IF DIRECTION,
	FROMDR=PRSO
C						!SAVE AND
	PRSO=0
C						!CLEAR.
50	IF(HERE.EQ.AROOM(PLAYER)) GO TO 100
C						!PLAYER JUST MOVE?
	CALL RSPEAK(2)
C						!NO, JUST SAY DONE.
	PRSA=WALKIW
C						!SET UP WALK IN ACTION.
	RETURN
C
100	IF(LIT(HERE)) GO TO 300
C						!LIT?
	CALL RSPEAK(430)
C						!WARN OF GRUE.
	RMDESC=.FALSE.
	RETURN
C
300	RA=RACTIO(HERE)
C						!GET ROOM ACTION.
	IF(FULL.EQ.1) GO TO 600
C						!OBJ ONLY?
	I=RDESC2(HERE)
C						!ASSUME SHORT DESC.
C 2021/09/21 Darth Spectra (Lydia Marie Williamson):
C The following comment, referring to the .OR.PROB(80,80) below,
C was found in the 1991 C translation:
C The next line means that when you request VERBOSE mode,
C you only get long room descriptions 20% of the time.
C I don't either like or understand this,
C so the modification ensures VERBOSE works all the time.
C 1987/10/22 jmh@ukc.ac.uk
	IF((FULL.EQ.0)
     &	.AND.(SUPERF.OR.(((IAND(RFLAG(HERE),RSEEN)).NE.0)
     &	        .AND.(BRIEFF.OR.PROB(80,80)))))       GO TO 400
	I=RDESC1(HERE)
C						!USE LONG.
	IF((I.NE.0).OR.(RA.EQ.0)) GO TO 400
C						!IF GOT DESC, SKIP.
	PRSA=LOOKW
C						!PRETEND LOOK AROUND.
	IF(.NOT.RAPPLI(RA)) GO TO 100
C						!ROOM HANDLES, NEW DESC?
	PRSA=FOOW
C						!NOP PARSER.
	GO TO 500
C
400	CALL RSPEAK(I)
C						!OUTPUT DESCRIPTION.
500	IF(AVEHIC(WINNER).NE.0) CALL RSPSUB(431,ODESC2(AVEHIC(WINNER)))
C
600	IF(FULL.NE.2) CALL PRINCR(FULL.NE.0,HERE)
	RFLAG(HERE)=IOR(RFLAG(HERE),RSEEN)
	IF((FULL.NE.0).OR.(RA.EQ.0)) RETURN
C						!ANYTHING MORE?
	PRSA=WALKIW
C						!GIVE HIM A SURPISE.
	IF(.NOT.RAPPLI(RA)) GO TO 100
C						!ROOM HANDLES, NEW DESC?
	PRSA=FOOW
	RETURN
	END
C
C Routing routine for room applicables
	LOGICAL FUNCTION RAPPLI(RI)
	IMPLICIT INTEGER(A-Z)
	LOGICAL RAPPL1,RAPPL2
	DATA NEWRMS/38/
C
	RAPPLI=.TRUE.
C						!ASSUME WINS.
	IF(RI.EQ.0) RETURN
C						!IF ZERO, WIN.
	IF(RI.LT.NEWRMS) RAPPLI=RAPPL1(RI)
C						!IF OLD, PROCESSOR 1.
	IF(RI.GE.NEWRMS) RAPPLI=RAPPL2(RI)
C						!IF NEW, PROCESSOR 2.
	RETURN
	END
